<!DOCTYPE html>
<html>
    <head>
        <title>Weathermap test</title>

        <script src="https://d3js.org/d3.v6.min.js"></script>
        <script
            src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
            crossorigin="anonymous"></script>

        <style type="text/css">
            *{
                margin: 0;
                padding: 0;
            }
            html, body{
                width: 100%;
                height: 100%;
                font-size: 10px;
            }

            /*
                Only used for styling the JSON buttons
            */
            #json-selectors{
                font-size: 2rem;
                padding: 2rem;
            }

            #json-selectors a{
                margin-right: 1rem;
                padding: 1rem;
                border: 1px solid #ddd;
            }

            svg{
                width: 1500px;
                height: 1000px;
            }
                svg .link-text{
                    font-size: 1.5rem;
                }

                svg .node-text{
                    font-size: 1.5rem;
                    font-weight: bold;
                }

                svg .link-down{
                    stroke-dasharray: 10;
                }
        </style>



    </head>
    <body>
        <div id="json-selectors">
            Select JSON: <a href="?source=example-json/data.json">data.json</a>
            <a href="?source=example-json/data-core.json">data-core.json</a>
            <a href="?source=example-json/bgp-state-machine.json">bgp-state-machine.json</a>
            <a href="?source=example-json/minimal.json">minimal.json</a>
        </div>

        <svg id="canvas">
            <defs>
                <svg id="router" width="100%" height="100%" viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
                    <g>
                        <circle cx="150" cy="150" r="150" style="fill:rgb(255,254,254);"/>
                        <path d="M150,0C232.787,0 300,67.213 300,150C300,232.787 232.787,300 150,300C67.213,300 0,232.787 0,150C0,67.213 67.213,0 150,0ZM150,16C223.957,16 284,76.043 284,150C284,223.957 223.957,284 150,284C76.043,284 16,223.957 16,150C16,76.043 76.043,16 150,16Z" style="fill:rgb(77,77,77);"/>
                        <g transform="matrix(0.852016,0,0,0.852016,41.581,41.4926)">
                            <path d="M138.458,152.273L138.458,202.269L158.915,181.814L158.846,213.18L127.346,244.68L95.912,213.245L95.912,181.769L116.43,202.287L116.43,152.415L138.458,152.273ZM194.491,116.43L244.364,116.43L244.505,138.458L194.509,138.458L214.964,158.915L183.599,158.846L152.099,127.346L183.533,95.912L215.009,95.912L194.491,116.43ZM70.967,158.915L39.49,158.915L60.009,138.397L10.136,138.397L9.994,116.369L59.99,116.369L39.536,95.912L70.901,95.981L102.401,127.481L70.967,158.915ZM116.369,102.434L116.369,52.438L95.912,72.893L95.981,41.527L127.481,10.028L158.915,41.462L158.915,72.938L138.397,52.42L138.397,102.292L116.369,102.434Z" style="fill:rgb(77,77,77);"/>
                        </g>
                    </g>
                </svg>
            </defs>

        </svg>

        <script>
            $(document).ready(function(){
                /*
                    Some navigation haxxxing to make the buttons work
                    This is not related to the functioning of peeew-topoflow at all
                */
                const queryString = window.location.search;
                const urlParams = new URLSearchParams(queryString);
                let json_source = urlParams.get('source');
                if(json_source === null){
                    json_source = 'example-json/data.json';
                }


                /*
                    Initialize the SVG element
                */
                let svg_container = d3.select("#canvas");
                let main_group = svg_container.append("g")
                    .attr('class', 'main_group');
                let svg = main_group;




                /*
                    #########################
                    #                       #
                    #       VARIABLES       #
                    #                       #
                    #########################
                */

                /*
                    Defines the default options for the maps. This is to be able to override options by each JSON source.
                */
                let options = {
                    /*
                        All colors definitions goes here
                    */
                    'colors': {
                        'circle_fill': '#000',
                        'circle_outline': '#fff',
                        'arrow_pointer': '#fff',
                        'svg_background_color': '#000',
                        'link': '#fff',
                        'link_down': '#f00',
                        'link_text': '#f0a',
                        'node_text': '#fff',
                        'arrow_pointer': '#fff'
                    },

                    /*
                        All text/font properties goes here
                    */
                    'text': {
                        /*
                            Where node text position should be. Supported: 
                                * bottom
                                * <anything else than bottom> (which will be drawn centered)
                        */
                        'node_position': 'bottom',

                        /*
                            Whether or not the optional text on the links should be rotated along the link or not
                            false: no rotation
                            true: text is rotated along the link
                        */
                        'link_rotation': true,

                        /*
                            Prevents the link text from being displayed upside down (180 degrees)
                        */
                        'link_prevent_upside_down': true
                    },


                    /*
                        Sets the radius of the node, if node type is not specified, or node type is "circle"
                        default: 40
                    */
                    'node_radius': 40,

                    /*
                        Then drawing multiple links between the same two nodes, this offset will be used to space the links evenly out.
                    */
                    'link_offset': 20,

                    /*
                        Not implemented yet
                    */
                    'display_fullscreen': false,
                    'svg_width': 1500,
                    'svg_height': 1000
                };


                // var node_radius = 40;

                let markerBoxWidth = 20
                let markerBoxHeight = 20
                let arrowPoints = [[0, 0], [0, 20], [20, 10]];

                let dataset_suggested_format = {
                    "links": [
                        {
                            "from": "00a-core-1",
                            "to": "00a-core-2",
                            "links": [
                                {
                                    "type": "1way",
                                    "max_out": "20",
                                    "max_in": "20",
                                    "rate_out": "331 M",
                                    "rate_in": "337 M",
                                    "state": "up"
                                },
                                {
                                    "type": "1way",
                                    "max_out": "20",
                                    "max_in": "20",
                                    "rate_out": "331 M",
                                    "rate_in": "337 M",
                                    "state": "up"
                                }
                            ]
                        },
                        {
                            "from": "00a-core-1",
                            "to": "00b-core-1",
                            "links": [
                                {
                                    "type": "2way",
                                    "max_out": "20",
                                    "max_in": "20",
                                    "rate_out": "331 M",
                                    "rate_in": "337 M",
                                    "state": "up"
                                },
                                {
                                    "type": "2way",
                                    "max_out": "20",
                                    "max_in": "20",
                                    "rate_out": "331 M",
                                    "rate_in": "337 M",
                                    "state": "up"
                                }
                            ]
                        },
                        {
                            "from": "00a-core-1",
                            "to": "00a-core-2",
                            "links": [
                                {
                                    "type": "1way",
                                    "max_out": "20",
                                    "max_in": "20",
                                    "rate_out": "331 M",
                                    "rate_in": "337 M",
                                    "state": "up"
                                }
                            ]
                        },
                    ]
                };



                /*
                    To hold all the magic. All the links and nodes
                    dataset.nodes.blabla
                    dataset.links.blabla
                */
                let dataset = {};


                /*
                    Required parameters for adding a node
                */
                let required_node_parameters = [
                    'x', // x coordinate
                    'y', // y coordinate
                    'name' // name of node
                ]


                /*
                    Required parameters for adding a link
                */
                let required_link_parameters = [
                    'x1', // start x coordinate
                    'y1', // start y coordinate
                    'x2', // end y coordinate
                    'y2' // end y coordinate
                ]








                /*
                    #########################
                    #                       #
                    #       FUNCTIONS       #
                    #                       #
                    #########################
                */


                /**
                    * Will provide a list of link offset placements. This enables us to draw multiple links between nodes.
                    * In the example "number_of_links" being 5 and "link_offset" being 10 will wield the following result: [-20, -10, 0, 10, 20].
                    * If number_of_links === 1, the result will be [0] ("center the link")

                    * @param {number} number_of_links: Number of links, to calculate the correct offset
                    * @returns {list}: Offset values, from lowest to highest
                */
                function calculate_offsets(number_of_links){
                    /*
                        Prevents "division by zero" crash
                    */
                    if(number_of_links === 0){
                        return false;
                    }

                    /*
                        Quick and dirty "if its 1, lets just return the center position"
                    */
                    if(number_of_links === 1){
                        return [0];
                    }

                    /*
                        Do the calculations
                    */
                    let data = [];
                    let half_link_offset = options.link_offset/2;
                    let lowest_offset = (half_link_offset*number_of_links-half_link_offset)*-1;
                    for (i = lowest_offset; i <= lowest_offset*-1; i += options.link_offset){
                        data.push(i);
                    }
                    return data;
                }


                /**
                    * Will draw a node on the map

                    * @param {object}       Parameters. See "required_node_parameters" variable for list of required variables.
                    * @return {boolean}     True on success, false on error (like missing parameters). Check console output for errors.
                */
                function draw_node(args){
                    /*
                        Validating args to confirm required node parameters
                    */
                    for(prop in required_node_parameters){
                        if(required_node_parameters[prop] in args !== true){
                            console.log('Error: unable to draw node. Missing parameter "' + required_node_parameters[prop] + '"');
                            return false;
                        }
                    }

                    console.log('Drawing node ' + args.name);

                    /*
                    if('type' in args){
                        if(args.type == 'router'){
                            console.log('ROUTER');
                        }
                    }
                    */


                    /*
                        Add node
                    */
                    console.log('options.node_radius:' + options.node_radius);
                    let node = svg.append("circle")
                        .attr('cx', args.x)
                        .attr('cy', args.y)
                        .attr('r', options.node_radius)
                        .attr('stroke-width', 5)
                        .attr('stroke', options.colors.circle_outline)
                        .style('fill', options.colors.circle_fill)
                        .attr('data-node-name', 'asdf')
                        .on("click", function(){
                            console.log(d3.select(this));
                        })
                        .on("mouseover", function(d) {
                            d3.select(this).style("fill", "#3236a8");
                        }).on("mouseout", function(d) {
                            d3.select(this).style("fill", options.colors.circle_fill);
                        });

                    /*
                        If the node text should be drawn in center of the node, or below.
                    */
                    let node_text_location = args.y;
                    if(options.text.node_position === 'bottom'){
                        node_text_location = args.y+(options.node_radius*1.4)
                    }

                    svg.append("text")
                        .attr('class', 'node-text')
                        .attr('x', args.x)
                        .attr('y', node_text_location)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('fill', options.colors.node_text)
                        .text(args.name)

                    if('state' in args){
                        if(args.state == 'down'){
                            console.log('ROUTER DOWN');
                            node.attr('stroke', '#f00');
                        }
                    }
                }

                /*
                    arg must contain:
                    * from
                    * to
                */
                function draw_link(args){
                    console.log('Drawing link from ' + args.from + ' to ' + args.to);
                    console.log(args);

                    //Global settings
                    let split_point = 0.5;
                    let text_pos = 0.5;

                    let midpoint_offset = 20;

                    let from_node_pos_x = dataset.nodes[args.from].x;
                    let from_node_pos_y = dataset.nodes[args.from].y;

                    let to_node_pos_x = dataset.nodes[args.to].x;
                    let to_node_pos_y = dataset.nodes[args.to].y;



                    let halfway_pos_x = to_node_pos_x-(to_node_pos_x-from_node_pos_x)*split_point;
                    let halfway_pos_y = to_node_pos_y-(to_node_pos_y-from_node_pos_y)*split_point;

                    /*
                        Calculate the angle of the line. used to rotate the text to fit inside the arrow line
                        https://stackoverflow.com/questions/34293488/d3-find-the-angle-of-line
                    */
                    let angle_a_to_b = Math.atan2(to_node_pos_y - from_node_pos_y, to_node_pos_x - from_node_pos_x);
                    let degrees = angle_a_to_b*(180/Math.PI)


                    /*
                        To flip the text rotation the easy way for humans to read (e.g. never upside down)
                    */
                    text_degrees = 0;
                    if(options.text.link_rotation === true){
                        text_degrees = degrees;

                        if(options.link_prevent_upside_down === true && text_degrees > 90 && text_degrees < 181){
                            text_degrees += 180;
                        }
                    }


                    /*
                        Assign rate (used bandwidth)
                    */
                    let rate_in = '',
                        rate_out = '';

                    if('rate_in' in args){
                        rate_in = args.rate_in; 
                    }
                    if('rate_out' in args){
                        rate_out = args.rate_out; 
                    }


                    /*
                        Assign state
                    */
                    let link_state = 'up';
                    if('state' in args){
                        if(args.state == 'down'){
                            link_state = 'down';
                        }
                    }

                    /*
                        A -> B
                    */
                    let newly_created_link = svg
                        .append('line')
                            .attr('class', 'link link-' + link_state)
                            .attr('x1', from_node_pos_x)
                            .attr('y1', from_node_pos_y)
                            .attr('x2', halfway_pos_x - Math.cos(angle_a_to_b) * midpoint_offset)
                            .attr('y2', halfway_pos_y - Math.sin(angle_a_to_b) * midpoint_offset)
                            .attr('stroke', options.colors.link)
                            .attr('stroke-width', 20)
                            .attr('marker-end', 'url(#arrow)')
                            .on("click", function(){
                                console.log(d3.select(this).attr('y1'));
                            });

                    /*
                        Draw link as "link down"
                    */
                    if(link_state == 'down'){
                        newly_created_link.attr('stroke', options.colors.link_down);
                    }

                    /*
                        B -> A
                    */
                    svg
                        .append('line')
                            .attr('class', 'link link-' + link_state)
                            .attr('x1', to_node_pos_x)
                            .attr('y1', to_node_pos_y)
                            .attr('x2', halfway_pos_x- Math.cos(angle_a_to_b + Math.PI) * midpoint_offset)
                            .attr('y2', halfway_pos_y- Math.sin(angle_a_to_b + Math.PI) * midpoint_offset)
                            .attr('stroke', options.colors.link)
                            .attr('stroke-width', 20)
                            .attr('marker-end', 'url(#arrow)')
                            .on("mouseover", function(d) {
                                d3.select(this).style("stroke", "#3236a8");
                            })
                            .on("mouseout", function(d) {
                                d3.select(this).style("stroke", options.colors.link);
                            })
                            .on("click", function(){
                                console.log(d3.select(this).attr('y1'));
                            });


                    if(link_state !== 'down'){

                        /*
                            Text on A -> B
                        */
                        draw_text_on_link({
                            x: from_node_pos_x+((to_node_pos_x-from_node_pos_x)*split_point*text_pos),
                            y: from_node_pos_y+((to_node_pos_y-from_node_pos_y)*split_point*text_pos),
                            text: rate_in
                        });

                        /*
                            Text on B -> A
                        */
                        draw_text_on_link({
                            x: to_node_pos_x-((to_node_pos_x-from_node_pos_x)*split_point*text_pos),
                            y: to_node_pos_y-((to_node_pos_y-from_node_pos_y)*split_point*text_pos),
                            text: rate_out
                        });
                    }
                }


                /**
                    * Used for placing text on links
                    * @param {object} args: must contain 'x', 'y' and 'text'
                    * @return {boolean}
                */
                function draw_text_on_link(args){
                    svg.append("text")
                        .attr('class', 'link-text')
                        .attr('x', args.x)
                        .attr('y', args.y)
                        .attr('transform', 'rotate(' + text_degrees + ', ' + (args.x) + ', ' + (args.y) + ')') // rotates the text
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .style('fill', options.colors.link_text)
                        .text(args.text)
                    return true;
                }


                /*
                    * Used for drawing a 1 way link
                    * @param 
                */
                function draw_link_1way(args){
                    console.log('Drawing 1way link from ' + args.from + ' to ' + args.to);
                    console.log(args);

                    //Global settings

                    let text_pos = 0.5;
                    let rotate_text = true; 
                    let link_state = '';

                    console.log(dataset.nodes);
                    let from_node_pos_x = dataset.nodes[args.from].x;
                    let from_node_pos_y = dataset.nodes[args.from].y;

                    let to_node_pos_x = dataset.nodes[args.to].x;
                    let to_node_pos_y = dataset.nodes[args.to].y;

                    let angle_a_to_b = Math.atan2(to_node_pos_y - from_node_pos_y, to_node_pos_x - from_node_pos_x);
                    let degrees = angle_a_to_b*(180/Math.PI)

                    /*
                        To flip the text rotation the easy way for humans to read (e.g. never upside down)
                    */
                    let text_degrees = 0;
                    if(rotate_text != false){
                        text_degrees = degrees;
                        if(text_degrees > 90 && text_degrees < 181){
                            text_degrees += 180;
                        }
                    }

                    /*
                        Assign state
                    */

                    if('state' in args){
                        if(args.state == 'down'){
                            link_state = 'down';
                        }
                    }else{
                        link_state = 'up';
                    }

                    /*
                        A -> B
                    */
                    svg
                        .append('line')
                            .attr('class', 'link link-' + link_state)
                            .attr('x1', from_node_pos_x)
                            .attr('y1', from_node_pos_y)
                            .attr('x2', to_node_pos_x- (Math.cos(angle_a_to_b) * (options.node_radius+25)))
                            .attr('y2', to_node_pos_y - (Math.sin(angle_a_to_b) * (options.node_radius+25)))
                            .attr('stroke', options.colors.link)
                            .attr('stroke-width', 20)
                            .attr('marker-end', 'url(#arrow)')
                            .on("click", function(){
                                console.log(d3.select(this).attr('y1'));
                            });

                  
                    if('rate' in args){
                        /*
                            Draw text
                        */
                        if(link_state !== 'down'){
                            draw_text_on_link({
                                x: from_node_pos_x+((to_node_pos_x-from_node_pos_x)*text_pos),
                                y: from_node_pos_y+((to_node_pos_y-from_node_pos_y)*text_pos),
                                text: args.rate
                            });
                        }
                    }
                }


                /*
                    Populate the dataset
                    Prevent caching
                */
                function run(){
                    console.log('run() called');
                    $.getJSON(json_source, {_: new Date().getTime()}, function(data){
                        // svg.selectAll(".svg_container").remove();
                        dataset = data;

                        console.log('data loaded from json file', data);

                        /**
                            * Conditionally overrides the default options from the options in the loaded JSON object "data"
                            * Will only override if the option is already defined in the "options" object
                            @todo Fix ugly hax, actually iterate recursively through object
                        */
                        if('options' in data){
                            for([key, value] of Object.entries(data.options)){
                                console.log(key, value);
                                
                                // Check if the value is an object
                                if(key in options && typeof value === 'object' && value !== null){
                                    for([key2, value2] of Object.entries(data.options[key])){
                                        console.log(key2, value2);
                                        options[key][key2] = data.options[key][key2];
                                    }
                                }else if(key in options){
                                    options[key] = data.options[key];
                                }
                                
                            }
                        }

                        console.log('options now', options);

                        $.each(data.links, function(key, link_prop){
                            //Identify multiple links
                        });

                        $.each(data.links_1way, function(key, link_prop){
                            draw_link_1way(link_prop);
                        });

                        $.each(data.links, function(key, link_prop){
                            draw_link(link_prop);
                        });

                        $.each(data.nodes, function(node_name, node_prop){
                            node_prop.name = node_name;
                            draw_node(node_prop);
                        });
                    });
                }





                /*
                    ################################
                    #                              #
                    #       SEQUENCIAL BLOCK       #
                    #     Setting up the stuff     #
                    #                              #
                    ################################
                */

                /*
                    Create marker(s)
                */
                d3.select("defs")
                    .append('marker')
                        .attr('id', 'arrow')
                        .attr('class', 'arrow')
                        .attr('viewBox', [0, 0, markerBoxWidth, markerBoxHeight])
                        .attr('refX', 1) // 1 point overlap on marker and line
                        .attr('refY', 10)
                        .attr('markerWidth', markerBoxWidth)
                        .attr('markerHeight', markerBoxHeight)
                        .attr('orient', 'auto-start-reverse')
                        .attr('markerUnits', 'userSpaceOnUse') // Needed, or the arrow head will inherit the stroke-width of the line "parent"
                        .attr('fill', options.colors.arrow_pointer)
                        .append('path')
                            .attr('d', d3.line()(arrowPoints));

                /*
                    changing the color of the SVG object, as defined in options.colors
                */
                svg_container.style('background-color', options.colors.svg_background_color);



                /*
                    Do the magic!
                */
                run();
                /*
                setInterval(function() {
                    run();
                }, 5000);
                */
            });
        </script>
    </body>
</html>